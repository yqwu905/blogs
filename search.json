[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Yuanqing Wu",
    "section": "",
    "text": "这是我的个人博客, 如果有任何疑问请通过邮件联系我.\n本站的所有内容均可以在不需要任何授权和告知的情况下转载使用.\n如果本站的任何内容侵犯了您的版权, 请联系我删除."
  },
  {
    "objectID": "posts/黑体辐射/黑体辐射.html",
    "href": "posts/黑体辐射/黑体辐射.html",
    "title": "黑体辐射",
    "section": "",
    "text": "我们首先需要讨论一下黑体辐射体系的特征. 黑体辐射问题实际上讨论的是, 处于热平衡状态下的光子气体的分布. 有以下特征:\n\n光子是交换对称的, 即遵循玻色分布.\n在不考虑QED的情况下, 光子与光子间不存在相互作用, 即光子气体是理想气体.\n由于光子可以被吸收和发射, 因此体系的粒子数\\(N\\) 是一个变量, 由热平衡条件决定, 即:要求\n\n\\[ \\frac{\\partial F}{\\partial N} = 0 \\]\n同时由定义可知:\n\\[ \\left(\\frac{\\partial F}{\\partial N}\\right)_{T,V} = \\mu \\]\n即光子气体化学势为0.\n那么我们可以立刻写出对于光子气, 所谓的Planck分布:\n\\[ \\overline{n}_{k} = \\frac{1}{e^{\\hbar \\omega/T}-1} \\tag{1}\\]\n我们继续研究频率在\\(\\omega\\sim \\omega+{\\rm d} \\omega\\) 间的量子态数:\n在波矢 \\(k\\) 空间中, 半径为\\(k\\sim k+{\\rm d}k\\) 的球壳内的本征振动数为:\n\\[ \\frac{V}{(2 \\pi)^{3}}4 \\pi k^{2}{\\rm d}k \\]\n注意到每个振动模式都相应的有两个偏振态, 因此上式需要乘2, 并代入\\(\\omega=ck\\), 我们得到\\(\\omega\\sim \\omega+{\\rm d} \\omega\\) 间的量子态数:\n\\[ \\frac{V \\omega^{2} {\\rm d} \\omega}{\\pi^{2}c^{3}} \\tag{2}\\]\n将量子态数式\\((2)\\)乘以对应的占据数式\\((1)\\), 我们就得到了\\(\\omega\\sim \\omega+{\\rm d} \\omega\\) 间的光子数:\n\\[ {\\rm d}N_{\\omega} = \\frac{V}{\\pi^{2}c^{3}} \\frac{\\omega^{2}{\\rm d}\\omega}{e^{\\hbar \\omega/T}-1} \\tag{3}\\]\n相应的能量为式\\((3)\\)乘 \\(\\hbar \\omega\\):\n\\[ {\\rm d}E_{\\omega} = \\frac{V\\hbar}{\\pi^{2}c^{3}}\\frac{\\omega^{3}{\\rm d} \\omega}{e^{\\hbar \\omega/T}-1} \\]\n\n\n\nPlanck的出发点是如下的假设: > 光子的能量一定为: > \\[ \\epsilon_{\\omega} = n\\hbar\\omega,\\quad n\\in\\mathbb{N} \\]\n由此, 体系的配分函数为:\n\\[ Z(\\omega) = \\sum_{n=0}^{\\infty}e^{-n \\beta \\hbar \\omega}  = \\frac{1}{1-e^{-\\beta \\hbar \\omega}} \\tag{4}\\]\n相应的平均能量为:\n\\[ E_{\\omega} = -\\frac{{\\rm d}}{{\\rm d} \\beta} \\ln Z = \\frac{\\hbar \\omega}{e^{\\beta \\hbar \\omega}-1} \\tag{5} \\]\n\\(\\omega\\sim \\omega+{\\rm d} \\omega\\) 间的量子态数应当得到相同的结果, 将式\\((2)\\) 与式\\((5)\\) 相乘, 我们得到能量分布:\n\\[ {\\rm d} E_{\\omega} = \\frac{V\\hbar}{\\pi^{2}c^{3}}\\frac{\\omega^{3}{\\rm d} \\omega}{e^{\\hbar \\omega/T} - 1}\\]\n\n\n\n对于两者的推导, 频率区间内的量子态的数量是相同的, 不同之处在于, 对于Bose的推导, 我们是求得对于其中每个量子态的平均占有数, 再乘以单光子的能量\\(\\hbar \\omega\\), 而对于Planck的推导, 则是求得在这个态上的平均能量, 直接乘以态密度 那么为什么这两者能得出相同的结论呢?\n我的理解是, Planck的假设实际上包含了Bose统计的假设. 光子的能量为\\(n \\hbar \\omega\\) 意味着什么? 我们都知道, 频率为\\(\\omega\\) 的光子能量为\\(\\hbar \\omega\\), 因此这一假设实际上包含两重含义:\n\n频率为\\(\\omega\\) 的态上的光子数是任意(\\(n\\))的.\n光子之间是不可分辨(否则不同的n会相应的有一个不同的组合系数).\n\n所以Planck的做法(式\\((4)\\))实际上是在对光子数进行求和, 相应的, 得到的平均占有数应当为:\n\\[ \\frac{E_{\\omega}}{\\hbar \\omega} = \\frac{1}{e^{\\beta \\hbar \\omega}-1} \\]\n正与Bose统计导出的光子气平均占有数相同."
  },
  {
    "objectID": "posts/BlogMigrate/BlogMigrate.html",
    "href": "posts/BlogMigrate/BlogMigrate.html",
    "title": "网站迁移记录",
    "section": "",
    "text": "由于之前技术力过于低下, 导致之前网站很多地方设置冲突且难以修复, 并且博客加载速度堪忧. 因此干脆直接服务器重装, 然后进行网站迁移. 为了方便日后查询, 记录一下迁移过程.\n\n\n之前的LAMP环境我用的是宝塔一键配置的, 但是宝塔面板这个东西用久了在我的破烂机器上总是容易有一些奇怪的问题. 因此这次重装我就直接 放弃了宝塔面板, 自己手动安装.\n系统选用的是Ubuntu 18.04.1 LTS, 问就是够用就行(话说真的会有人在服务器上装Arch吗).\n网站服务这边我直接放弃了PHP和MYSQL, 第一是没有数据库和动态页面的硬需求, 第二是自己对这两个都不熟悉, 因此只装个Nginx提供网页服务.\n\n\n\n\n\n这次直接放弃对站点作CDN, 只在图片服务上用了CDN(image.yqwu.site).\n目前使用了四个域名:\n\nyqwu.site, 主站点, 用于挂一些时效性比较久/需要直接写html来实现一些特殊功能的(事实上没有).\nimage.yqwu.site, 图床, 由七牛云提供服务.\ngit.yqwu.site, 个人的Git仓库, 基于gogs.\nblog.yqwu.site, 博客站点, 实际上只是映射到了yqwu.site下的blog目录中.\n\n记录一下blog.yqwu.site的Nginx配置:\n# /etc/nginx/sites-available/blog.conf\nserver {\n  listen 443 ssl;\n  server_name blog.yqwu.site;\n  root /var/www/html/blog;\n  index index.html index.htm;\n  location / {\n    try_files $uri $uri/ =404;\n  }\n}\n以及git.yqwu.site的端口转发:\n# /etc/nginx/sites-available/git.conf\nserver {\n  listen 443 ssl;\n  server_name git.yqwu.site;\n\n  location / {\n    proxy_pass https://yqwu.site:3000;\n  }\n}\ngogs不需要什么额外的配置, 只需要正确的指定证书文件就可以了.\n\n\n\n同时, 对于SSL这个上次最重要的问题, 这次我是用certbot申请的let’s encrypt 的证书, 吸取上次的经验, 这次申请一个主域名yqwu.site和一个泛域名*.yqwu.site的证书. 唯一的缺点就是certbot不支持泛域名的自动 续签. 不过泛域名的优点远大于每三个月自己手动续签一次的麻烦了.\n\n谈一下为什么这次要申请泛域名. 一个就是方便管理, 避免后面再需要使用其他子域名的时候申请新的证书. 另外就是国内的几个CDN厂商 (点名七牛云,百度和阿里)都不支持Let's encrypt的证书(不是不支持加密, 是不支持转发来实习自动续签). 因此自动续签总是出问题. 所以不如直接用泛域名.\n\n\n\n\n\n\n\n这次没用啥博客框架了(我总是弄的加载很慢), 直接Markdown编写加Pandoc转成HTML, 配个CSS和KaTeX, 基本的功能 是没啥问题, 还蛮方便(hexo的Markdown规范太严格了, 很多用法都不支持).\n然后手撸了一个根据Blog文件夹下的Markdown文件生成博客主页的脚本, 用起来还行(虽然啥功能也没有, 但能插二刺螈图就够了).\n\n\n\n直接用sshfs把服务器目录挂载下来, 然后编辑和生成都在本地做就好了, 省的之前用hexo的时候本地生成了还要SCP传上去(不过也是因为我这个 脚本没啥大的文件IO, hexo那种复杂的框架在sshfs上跑估计不太行).\n\n\n\nGit, 脚本和源文件都放在一个仓库里. 设置忽略所有生成的html文件就行了.\n\n\n\n\n\n这次给网站加了个License(虽然感觉没啥用):CC-SA.\n暂时是不准备给这个简陋的博客”系统”加什么功能了, 反正能用就行, 可以美其名曰加载快速."
  },
  {
    "objectID": "posts/AutomaticDifferentiation/AutomaticDifferentiation.html",
    "href": "posts/AutomaticDifferentiation/AutomaticDifferentiation.html",
    "title": "自动微分(Automatic Differentiation)",
    "section": "",
    "text": "对于几乎所有最优化方法来说, 最基础的一步就是求任意函数的微分. 例如梯度下降法(Gradient Descent). 因此, 微分算法的重要性自然不言而喻. 目前, 一共存在四种微分算法: * 手动微分(Manual Differentiation), 即手动求出函数的微分, 并直接编码进代码里. * 数值微分(Numerical Differentiation). 顾名思义, 求解任意函数在某一点的微分的数值解. * 符号微分(Symbolic Differentiation). 即Mathematica中提供的微分, 给出任意函数微分的解析表达式. * 自动微分(Automatic Differentiation).\n其中手动微分由于每次修改模型, 我们都需要更改求解梯度的代码, 并且对于维度较高的函数编码量很大, 因此较少采用, 我们在此也不会涉及.\n\n\n数值微分是最简单的一种计算微分的方法, 原理就是基于微分的定义: \\[ f'(x) = \\lim_{\\epsilon \\to 0} \\frac{f(x+\\epsilon) - f(x)}{\\epsilon}\\] 我们将\\(\\epsilon\\) 取一个极小值(例如\\(0.00001\\)), 代入计算即可得到数值微分. 较为常用的是中心差分法: \\[ f'(x) = \\lim_{\\epsilon \\to 0} \\frac{f(x+\\epsilon) - f(x-\\epsilon)}{2 \\epsilon} \\] 数值微分的优点是编码非常容易, 但缺点也很明显:第一, 计算量很大, 计算梯度时对于每个变量都需要计算两次函数值; 第二, 误差较大, 这一点在计算物理/数值方法课上应该都有过详细的讨论.\n\n\n\n符号微分即求得函数的微分的解析表达式. 其优点在于得到是精确解, 并且只需要求解一次表达式, 函数各点的微分都可以得到, 而缺点也很明显, 第一, 随着函数表达式复杂度的上升, 得到的微分解析式复杂度可能极速膨胀, 即所谓的”表达式膨胀”(expression swell)问题; 第二, 符号微分只能求解具有数学表达式形式的函数, 但很多时候我们使用的函数并不具有一个显式的表达式形式; 第三, 符号微分难以求解存在不可微点的函数.\n\n\n\n终于到了今天的主角, 自动微分. 自动微分的想法其实可以看作手动微分和数值微分的结合: 由于绝大多数函数的微分都可以通过查表得到, 因此我们只需要实现对几个基本函数的手动微分, 之后利用链式法则, 每步都带入数值求解, 就能实现对于任意函数的精确微分了.\n自动微分是目前综合性能最好的微分算法, 同时具有精确求解, 速度快, 可求解含有逻辑控制语句与部分不可微的函数等优点.\n\n\n\n\n我们从一个例子开始讲解前向的自动微分算法.\n考虑函数: \\[ f(x_1, x_2) = \\ln (x_1) + x_1 x_2 -\\sin(x_2) \\] 可以将其转化为如下的AST形式  各节点分别为: * \\(v_{-1}\\) :\\(x_1\\) * \\(v_0\\) :\\(x_2\\) * \\(v_1\\) :\\(\\ln v_{-1}\\) * \\(v_2\\) :\\(v_{-1}\\times v_0\\) * \\(v_3\\) :\\(\\sin v_0\\) * \\(v_4\\) :\\(v_1 + v_2\\) * \\(v_5\\) :\\(v_4+v_3\\)\n之后, 就可以很轻松的求解函数在各步的函数值与导数值, 如下表所示.  实现前向自动微分最简单的方法就是Dual Number法. 其核心思想是用\\(x+\\epsilon\\)替换 \\(x\\)作为输入, 利用Taylor展开: \\[ f(x+b \\epsilon) = f(x) + f'(x)b \\epsilon \\] 例如, 我们需要求解\\(\\frac{\\partial f}{\\partial x_1}\\), 则将\\(v_{-1}\\) 从\\(x_1\\)改为\\(x_1 + \\epsilon\\). 之后, 我们需要实现各种基本函数下\\(\\epsilon\\) 的作用率, 例如: * \\((a+b \\epsilon) + (c+ d \\epsilon) = (a+c) + (b+d) \\epsilon\\) * \\((a+b \\epsilon)\\times (c+d \\epsilon) = ac + (bc+ ad)\\epsilon\\) * \\(\\ln (a+b \\epsilon) = \\ln a + \\frac{b}{a}\\epsilon\\) * \\(\\sin (a+b \\epsilon) = \\sin(a)+ \\cos (a) b \\epsilon\\)\n之后, 依次计算各个节点: * \\(v_{-1} = 2 + \\epsilon\\) * \\(v_0 = 5\\) * \\(v_1 = \\ln 2 + \\frac{\\epsilon}{2}\\) * \\(v_2 = 10 + 5 \\epsilon\\) * \\(v_3 = \\sin 5\\) * \\(v_4 = 10 + \\ln 2 + \\frac{11 \\epsilon}{2} \\approx 10.693 + 5.5 \\epsilon\\) * \\(v_5 = 10.693 + \\sin 5 + 5.5 \\epsilon \\approx 11.652 + 5.5 \\epsilon\\)\n由此, 我们得到了在\\((x_1=2, x_2=5)\\)处, 函数值为\\(10.693\\), 对\\(x_1\\)的导数值为\\(5.5\\).\n代码上的实现也是很简单的, 我们只要构造Dual Number类型:\n\nstruct DualNumber <: Number\n    a::Float64;\n    ϵ::Float64;\nend\n\n然后将各个基本函数重载(这里我们只重载了几个需要的函数):\n\n# 重载运算符, 实现对DualNumber的运算\nBase.:+(x::DualNumber, y::DualNumber) = DualNumber(x.a + y.a, x.ϵ + y.ϵ);\nBase.:-(x::DualNumber, y::DualNumber) = DualNumber(x.a - y.a, x.ϵ - y.ϵ);\nBase.:*(x::DualNumber, y::DualNumber) = DualNumber(x.a * y.a, x.ϵ * y.a + x.a * y.ϵ);\nBase.log(x::DualNumber) = DualNumber(log(x.a), x.ϵ/x.a);\nBase.sin(x::DualNumber) = DualNumber(sin(x.a), cos(x.a) * x.ϵ);\nBase.tan(x::DualNumber) = DualNumber(tan(x.a), sec(x.a)^2*x.ϵ);\nBase.sqrt(x::DualNumber) = DualNumber(sqrt(x.a), x.ϵ/(2*sqrt(x.a)));\n\n实现前向自动微分的过程之后就相当简单了:\n\nfunction FowardAD(f, v::Vector{Float64})::Vector{Float64}\n    grad = Float64[]\n    for i in 1:length(v)\n        dualV = map(x->x==i ? DualNumber(v[x], 1) : DualNumber(v[x], 0), 1:length(v));\n        push!(grad, f(dualV).ϵ)\n    end\n    grad\nend\n\nFowardAD (generic function with 1 method)\n\n\n你很快就能发现我们这么做的优点:我们不需要对代码做任何更改, 我们可以接受并求解任何一个你能定义的函数. FowardAD函数接受一个任意的函数\\(f\\), 与一个\\(n\\)维的向量\\([v_1, v_2,\\cdots,v_{n}]\\), 返回\\(f\\)在 \\(v\\)处的梯度 \\([\\partial f/\\partial v_i]\\).\n下面是两个例子\n\ng(x) = log(x[1]) + x[1]*x[2] - sin(x[2])\nf(x) = sum(sin, x) + prod(tan, x) * sum(sqrt, x);\ny = [2., 5.]\nx = [0.986403, 0.140913, 0.294963, 0.837125, 0.650451];\nprintln(FowardAD(f, x));\nprintln(FowardAD(g, y));\n\n[1.0135827245997349, 2.500134089883427, 1.7257370110780195, 1.1013890171195015, 1.2445004882356923]\n[5.5, 1.7163378145367738]\n\n\n可以看出, 对于\\(f(x)\\) 这种维数不定, 难以写出解析形式的函数, 代数微分难以求解, 但自动微分依然能得出相当精确的结果.\n\n\n\n你可能会疑惑, 我们有了前向自动微分, 为什么还要研究什么Backward Mode自动微分呢? 答案很简单, 从前面的介绍你应当注意到, 对于一个\\(n\\) 维的函数, 如果我们想要求得它在某点的梯度, 那么我们需要进行\\(n\\) 次前向自动微分. 对于目前很多应用, 例如深度学习等, 函数的输入维数都是非常巨大的, 在这种情况下前向自动微分的效率就非常低, 这时就需要反向自动微分.\n反向自动微分的原理也非常简单, 先进行一次正向的求解, 计算出每个节点处的函数值, 之后利用链式法则, 从后向前依次求出各节点的导数. 仍然用之前的例子: \\[ f(x_1, x_2) = \\ln x_1 + x_1\\times x_2 - \\sin x_2\\]  其中\\(\\overline{v_{i}}\\) 指代\\(\\partial y/\\partial v_{i}\\). 需要注意的是, \\(v_{i}\\) 应该被保存, 以供后续使用.\n反向自动微分的原理非常简单, 但是实现上较前向自动微分困难一些. Dual Number方法不能使用, 我们需要构造AST, 从而进行反向求解.\n首先, 我们需要构造节点结构, 其中f标记函数类型, \\(0\\)为 \\({\\rm id}\\), \\(1\\)为加, \\(2\\) 为减, \\(3\\) 为乘…\nsons为子节点的列表, 长度取决于函数的参数个数.\nvalue为该节点的函数值.\nderi为该节点的导数值.\nid为该节点的id, 主要用于区分输入.\n\nmutable struct OpNode\n    f::Int64;\n    sons;\n    value::Float64;\n    deri::Float64\n    id::Int64;\nend\n\n接下来, 实现了OpNode的默认构造函数, 导数默认置\\(0\\), 等待反向传播时再进行计算. id自动加一.\n\nglobalID = 0;\nfunction OpNode(f, sons, value)\n    global globalID;\n    OpNode(f, sons, value, 0.0, globalID += 1);\nend\n\nOpNode\n\n\n之后实现了对几种基本运算的重载:\n\nfunction Base.:+(x::OpNode, y::OpNode)\n    return OpNode(1, [x, y], x.value + y.value);\nend\n\nfunction Base.:-(x::OpNode, y::OpNode)\n    return OpNode(2, [x, y], x.value - y.value);\nend\n\nfunction Base.:*(x::OpNode, y::OpNode)\n    return OpNode(3, [x, y], x.value * y.value);\nend\n\nfunction Base.log(x::OpNode)\n    return OpNode(4, [x], log(x.value));\nend\n\nfunction Base.sin(x::OpNode)\n    return OpNode(5, [x], sin(x.value));\nend\n\n注意, 至此我们就可以在不修改函数代码的情况下构造出一个AST, 同时完成前向计算各节点的函数值.\n现在, 我们可以来实现反向自动微分的核心代码了\n\nfunction evaluate(root::OpNode)\n    if root.f == 0\n        return ;\n    end\n    if root.f == 1\n        root.sons[1].deri += root.deri;\n        root.sons[2].deri += root.deri;\n        evaluate(root.sons[1]);\n        evaluate(root.sons[2]);\n        return ;\n    end\n    if root.f == 2\n        root.sons[1].deri += root.deri;\n        root.sons[2].deri -= root.deri;\n        evaluate(root.sons[1]);\n        evaluate(root.sons[2]);\n        return ;\n    end\n    if root.f == 3\n        root.sons[1].deri += root.deri*root.sons[2].value;\n        root.sons[2].deri += root.deri*root.sons[1].value;\n        evaluate(root.sons[1]);\n        evaluate(root.sons[2]);\n        return ;\n    end\n    if root.f == 4\n        root.sons[1].deri += root.deri/root.sons[1].value;\n        evaluate(root.sons[1]);\n        return ;\n    end\n    if root.f == 5\n        root.sons[1].deri += root.deri*cos(root.sons[1].value);\n        evaluate(root.sons[1]);\n        return ;\n    end\nend\n\nevaluate (generic function with 1 method)\n\n\n根据每个节点的函数种类, 我们应用链式法则求出其子节点的导数值. 之后递归调用求解其子节点, 直到sons为nothing,即抵达叶节点为止.\n下面这个函数可以从计算完成的树中取出指定id的节点的导数值, 用于输出.\n\nfunction getDeriByID(root::OpNode, id::Int64)\n    if root.id == id\n        return root.deri;\n    end\n    if root.sons === nothing\n        return ;\n    end\n    for i in root.sons\n        r = getDeriByID(i, id);\n        if r!==nothing\n            return r;\n        end\n    end\nend\n\ngetDeriByID (generic function with 1 method)\n\n\n之后, 我们就可以完成反向自动微分的完整逻辑了.\n\nfunction BackwardAD(f, v::Vector{Float64})::Vector{Float64}\n    res = zeros(length(v));\n    root = f(map(x->OpNode(0, nothing, x), v));\n    root.deri = 1.;\n    evaluate(root);\n    for i in 1:length(v)\n        res[i] = getDeriByID(root, i);\n    end\n    return res;\nend\n\nBackwardAD (generic function with 1 method)\n\n\n我们将输入向量v转变为一系列叶节点(即map(x->OpNode(0, nothing, x), v)语句), 并传入给定函数. 由于我们实现了对各基本操作的重载, 计算该函数时即完成了AST的构建和前向计算各节点函数值的过程, 并返回根节点. 之后, 将根节点的导数值设为1, 并开始反向自动微分. 完成后返回相应的梯度向量即可.\n一个相同的例子:\n\nf(x) = log(x[1]) + x[1]*x[2] - sin(x[2]);\nprintln(BackwardAD(f, [2., 5.]));\n\n[5.5, 1.7163378145367738]\n\n\n\n\n\n\n本文中所有图片来自于arXiv:1502.05767, 如果你想了解更多, 更严格的关于自动微分的内容, 强烈推荐你读一读这篇综述.\n本文中没有考虑多输出函数的情况. 实际上, 标准的Automatic Differentiation程序应当给出Jacobian矩阵, 而不是梯度向量. 相应的, 对于当输出维度很大, 而输入维度相对较小的情况下, 前向自动微分的性能就要优于反向自动微分了.\n关于两种自动微分, 本文中只展现了一个最简单, 最易实现的实现方式. 实际的自动微分有许多细节, 例如, 对AST进行图优化, 基于元编程的Differiatial Rule生成等等. 如果你想深入学习, 你应当读一读大项目中的AD实现. 作为推荐, Julia目前实现了一套相当好的可微分编程环境, 你可以读一读FowardDiff.jl以及ReverseDiff.jl的代码."
  },
  {
    "objectID": "posts/直积,直和与张量积/直积,直和与张量积.html",
    "href": "posts/直积,直和与张量积/直积,直和与张量积.html",
    "title": "直积,直和与张量积",
    "section": "",
    "text": "最近发现很多教材, 尤其是物理类的教材中对于直积, 直和与张量积的定义存在矛盾与含糊之处, 在此进行一些区分.\n\n\n\n\n直积(Direct Product)的定义与我们所熟知的笛卡尔积(Cartesian Product)相同, 用符号\\(\\times\\)标记\n\n\\(X\\)与\\(Y\\)为两个集合, 他们的直积\\(X\\times Y\\)定义为一个集合, 其元素为X和\\(Y\\)中元素的有序对,即:\n\\(\\forall x\\in X, y\\in Y, (x,y)\\in X\\times Y\\)\n\n可以看出直积有以下几个特点:\n\n是对于集合定义的.\n如果对于线性空间定义, 一个\\(n\\)维空间\\(X\\)和一个\\(m\\)维空间\\(Y\\), 其直积空间\\(X\\times Y\\)的维数为\\(n+m\\).\n实际上, 我们对于\\(X\\times Y\\)上的运算和结构没做任何规定.但一般我们总是让\\(x\\)和\\(y\\)分别继承之前的运算和结构,就像我们在直和中做的那样.\n\n\n\n\n直和(Direct Sum)用符号\\(\\oplus\\)标记, 定义为\n\n\\(V,W\\)为两定义在域\\(\\mathbb{F}\\)上的矢量空间, 他们的直和\\(V\\oplus W\\)定义为一个矢量空间, 其中的元素为\\(V\\)和\\(W\\)中元素的有序对, 并带有如下线性结构 \\[(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)\\] \\[\\alpha (x,y) = (\\alpha x, \\alpha y)\\] 其中\\(x,x_1,x_2 \\in V\\), \\(y,y_1, y_2 \\in W\\), \\(\\alpha\\in\\mathbb{F}\\).\n\n可以看出直和有以下特点:\n\n定义在矢量空间上的.\n\\(n\\)维矢量空间与\\(m\\)维矢量空间的直和空间维数为\\(n+m\\).\n直和空间带有天然的带有运算和结构.\n\n\n\n\n张量积(Tensor Product)的定义稍微显得复杂一点,同时注意, 我们使用\\(\\otimes\\)符号来同时标记对空间和张量的张量积, 为了不引起歧义, \\(A\\otimes B\\)这种大写字母指的是空间间的张量积, 而\\(a\\otimes b\\)指的是张量间的张量积. 我们先定义张量间的张量积\n\n对于两张量\\(a^{\\mu}{}_{\\nu}, b^{\\rho}{}_{\\sigma}\\), 其张量积定义为\\((a\\otimes b)^{\\mu\\rho}{}_{\\nu\\sigma}\\). 写成矩阵形式: \\[\\begin{aligned}\n&a^\\mu{}_\\nu = \\begin{pmatrix}a^1{}_1& a^1{}_2\\\\ a^2{}_1& a^2{}_2\\end{pmatrix}\\\\\\\\\n&b^\\rho{}_\\sigma = \\begin{pmatrix}b^1{}_1& b^1{}_2\\\\ b^2{}_1& b^2{}_2\\end{pmatrix}\\\\\\\\\n(a\\otimes b)^{\\mu\\rho}{}_{\\nu\\sigma} &= \\begin{pmatrix}a^1{}_1 b^\\rho{}_\\sigma& a^1{}_2b^\\rho{}_\\sigma\\\\ a^2{}_1b^\\rho{}_\\sigma& a^2{}_2b^\\rho{}_\\sigma\\end{pmatrix}\\\\\\\\\n&=\\begin{pmatrix}a^1{}_1 b^1{}_1 & a^1{}_1 b^1{}_2 & a^1{}_2 b^1{}_1& a^1{}_2 b^1{}_2\\\\ a^1{}_1b^2{}_1 & a^1{}_1b^2{}_2 & a^1{}_2 b^2{}_1 & a^1{}_2 b^2{}_2\\\\ a^2{}_1a^1{}_1 & a^2{}_1b^1{}_2 & a^2{}_2 b^1{}_1 & a^2{}_2 b^1{}_2\\\\ a^2{}_1a^2{}_1 & a^2{}_1b^2{}_2 & a^2{}_2 b^2{}_1 & a^2{}_2 b^2{}_2\\\\ \\end{pmatrix}\n\\end{aligned}\\] \\(V,W,U,X\\)为定义在域\\(\\mathbb{F}\\)上的矢量空间. \\(p:V\\times W\\to X\\) 为一个多线性映射, 则X为\\(V\\otimes W\\), \\(p\\)为\\(v\\otimes w\\),若对于任意多线性映射\\(A:V\\times W\\to U\\), 有且仅有一个线性映射\\(A^\\otimes :X\\to U\\), 使得\\(A=A^\\otimes \\circ p\\)\n\n张量积的性质:\n\n定义在矢量空间上,元素是张量(多线性映射).\n\\(n\\)维矢量空间与\\(m\\)维矢量空间的张量积空间维数为\\(nm\\).\n张量积空间天然带有多线性结构.\n\n\n\n\n\n\n\n直和与直积几乎没有什么区别, 仅有的两个区别在于:\n\n默认情况下, 直积可以对任何集合定义, 并且直积空间不附带任何结构. 但直和空间是对于两个矢量空间定义的, 自然带有线性结构.\n对于无限维空间, 直和空间的元素只能有有限个非零分量, 而直积空间的元素可以有任意个非零分量, i.e. 直和空间是直积空间的真子空间. (这是是一个定义, 不用问为什么).\n\n\n\n\n二者非常不一样, 主要来源于张量积空间保持了多线性结构. 举了例子来说明两者的区别. 考虑一个\\(2\\)维矢量空间\\(A\\)和一个\\(1\\)维矢量空间\\(B\\), 其基底分别为\\(\\{a_1,a_2\\}\\)和\\(\\{b_1\\}\\).其的直和空间\\(A\\oplus B\\)中任意元素: \\[\n(a\\cdot a_1,b\\cdot a_2,c\\cdot b_1)\n\\] 总可以将其分解为: \\[\na(a_1,0,0) + b(0,a_2,0) + c(0,0,b_1)\n\\] 可见, 直和空间是三维的, 再考虑其张量积空间\\(A\\otimes B\\)中的任意元素 \\[\n(a\\cdot a_1, b\\cdot a_2)\\otimes(c\\cdot b_1)\n\\] 可以写成: \\[\nac \\cdot a_1\\otimes b_1 + bc \\cdot a_2\\otimes b_1\n\\] 可以看出张量积空间是\\(2\\times 1 = 2\\)维的.\n其间的主要差异是由多线性结构引起的. 因为直和/直积空间只是将两个空间的元素按顺序放在一起,因此维数是两空间相加. 而张量积空间中, 由于多线性性, 我们有: \\[\n(a+b)\\otimes (c+d) = a\\otimes c + b\\otimes c + a\\otimes d + b\\otimes d\n\\] 因此维数是相乘.\n\n\n\n\n很多物理书中总喜欢将张量积和直积混淆, 我看到的最严重的就是喀兴林先生的《高等量子力学》一书, 甚至还在书中专门花了一节来讨论直和与直积空间的区别. 以后我要注意区分."
  },
  {
    "objectID": "posts/Mathematica包开发/Mathematica包开发.html",
    "href": "posts/Mathematica包开发/Mathematica包开发.html",
    "title": "Mathematica包开发(一)",
    "section": "",
    "text": "最近需要写一个Mathematica的Package, 但网上教程并不多, 官方文档冗长而又充斥着机翻, 因此做个笔记备忘.\n本篇将主要介绍一下常用于创建包的函数, Paclet和文档等内容将放在下一篇.\n\n\nWolfram语言中提供了一些方式来创建局部变量. 最常用的是Module和With.\n\nModule的定义:\n\nModule[{x, y, ...}, expr].\nModule[{x=x0, ...}, expr].\nModule会将x,y,...作为module内的局域变量处理, 并override module外的变量.\n如果Module对局域变量赋有初值, 那么该局域变量会在module执行前被赋值. 常见 的作用为将一个同名全局变量的值赋给局域变量.\nExamples\n\n局域变量\nIn[1]:= x = 10;\nOut[1]:= 10\nIn[2]:= Module[{x},\n          x = 9;\n          x\n        ]\nOut[2]:= 9\nIn[3]:= x\nOut[3]:= 10\n局域函数\nIn[1]:= fib[n_] :=\n          Module[{f},\n           f[1] = f[2] = 1;\n           f[i_] := f[i] = f[i - 1] + f[i - 2];\n           f[n]\n          ]\nIn[2]:= fib[10]\nOut[2]:= 55\nIn[3]:= f\nOut[3]:= f\n赋有初始值的module\ngcd[m0_, n0_] :=\n  Module[{m = m0, n = n0},\n   While[n != 0, {m, n} = {n, Mod[m, n]}];\n   m\n  ]\n\n\nWith的定义\n\nWith[{x=x0,y=y0, ... },expr]\n和Module不同, With必须给定局域变量的初始值, 同时, With会在执行前将所有局域 变量替换成给定的初始值, 这意味着With创建的是局域常数\nExamples\n\n尝试修改With声明的常量值:\nIn[1]:= With[{x = 10},\n          x = x + 1;\n        ]\nOut[1]:= Set::setraw: Cannot assign to raw object 10.\n可以看出With的效果类似于c中的#define, 在执行前直接被替换为给定值.\nWith的执行效率高于Module:\nIn[1]:= Timing[Do[Module[{x = 5}, x;], {10^5}]]\nOut[1]:= {0.109375, Null}\nIn[2]:= Timing[Do[With[{x = 5}, x;], {10^5}]]\nOut[2]:= {0.046875, Null}\n注意,With中执行的是替换, 因此可以代入Hold的表达式:\nIn[1]:= With[{x=y}, Hold[x]]\nOut[1]:= Hold[y]\nIn[2]:= With[{x=y}, Hold[x]]\nOut[2]:= Hold[x$138]\n其中,x$138的形式是Module用了代表内部每一个局部变量的,形式均为x$nnn, nnn为Module中任何形式使用变量的总次数, 记录于全局变量$ModuleNumber 中.\n\n\n\n\n\n\nBlock可以为一个全局变量创建一个局域值:\nIn[1]:= x = 10\nOut[1]:= 10\nIn[2]:= Block[{x=1},x]\nOut[2]:= 1\nIn[3]:= x\nOut[3]:= 10\n可以看出Block在不改变全局变量已有赋值的情况下, 为全局变量创建了一个局域值.\nModule和Block的区别主要在于:Module是声明一个局域变量, 而Block是全局变量的 一个局域值:\nIn[1]:= m = i^2\nOut[1]:= i^2\nIn[2]:= Block[{i = a}, i + m]\nOut[2]:= a + a^2\nIn[3]:= Module[{i = a}, i + m]\nOut[3]:= a + i^2\n从上面这个例子中你应当可以看出区别所在.\n\n\n\n为了避免不同程序包中的符号命名冲突, Wolfram语言中引入了类似于C++的namespace的 概念, 称为上下文:Context.\nWolfram语言中,任何变量名实际上都由两部分组成:上下文和变量名:\ncontext`name\n任何上下文都以`结尾, 当你启动一个Wofram进程时, 默认的上下文为Global',可以通 过Context[]或者$Context变量来查看当前的默认上下文.\n另外, Wolfram还可以加载一系列的模块, 他们可能包含不同的上下文, 为此, Wolfram语 言中引入了$ContextPath这一变量, 类似于系统的搜索路径, Wolfram会首先在 $ContextPath的上下文中搜索, 之后才会搜索当前的上下文.\nIn[1]:= $Context\nOut[1]= Global`\n\nIn[2]:= Context[]\nOut[2]= Global`\n\nIn[3]:= $ContextPath\nOut[3]= {NaturalLanguageProcessingLoader`, System`, Global`}\n\nIn[4]:= a = 1\nOut[4]= 1\n\nIn[5]:= Context[a]\nOut[5]= Global`\n\nIn[6]:= System`b = 2\nOut[6]= 2\n\nIn[7]:= Context[b]\nOut[7]= System`\n\nIn[8]:= Global`b = 3\nGlobal`b::shdw: Symbol b appears in multiple contexts {Global`, System`}; definitions in context Global` may shadow or be shadowed by other definiti\nons.\nOut[8]= 3\n\nIn[9]:= b\nOut[9]= 2\n\nIn[10]:= Global`b\nOut[10]= 3\n可以使用Begin和End来创建和关闭一个新的上下文:\nIn[1]:= Begin[\"newContext`\"] (* 相当于 $Context=\"newContext`\" *)\nOut[1]= newContext`\n\nIn[2]:= var1 = 100;\n        Context[var1]\nOut[2]= newContext`\n\nIn[3]:= Context[]\nOut[3]= newContext`\n\nIn[4]:= End[]\nOut[4]= newContext`\n\nIn[5]:= Context[]\nOut[5]= Global`\n在新的上下文中创建的变量无法只通过变量名访问:\nIn[1]:= var1\nOut[1]= Var1\n\nIn[2]:= newContext`var1\nOut[2]= 100\n将某一个上下文加入到$ContextPath中可以实现只是用变量名访问:\nIn[1]:= PrependTo[$ContextPath, \"newContext`\"]\nOut[1]= {newContext`, NaturalLanguageProcessingLoader`, System`, Global`}\n\nIn[2]:= var1\nOut[2]= 100\n\n\n\n可以使用BeginPackage和EndPackage函数来创建一个程序包:\nIn[1]:= BeginPackage[\"newPackage`\"]\n        n=2;\n        SumSquares[x_, y_] := x^n + y^n;\n        EndPackage[]\n\nIn[2]:= SumSquares[1, 2]\nOut[2]= 5\n\nIn[3]:= $ContextPath\nOut[3]= {newPackage`, NaturalLanguageProcessingLoader`, System`, Global`}\n可以看出, 创建Package会自动创建同名的上下文, 并自动添加到$ContextPath中.\n同时, Wolfram语言中也可以声明私有成员, 例如, 上例中的n是可以修改的:\nIn[1]:= n=3;\n        SumSquares[1, 2]\nOut[1]= 9\n可以通过在Package中创建Private上下文来声明私有成员:\nIn[1]:= BeginPackage[\"newPackage`\"]\n        SumSquares::usage = \"SumSquares[x, y] = x^2 + y^2\"\n        Begin[\"`Private`\"];\n        n=2;\n        SumSquares[x_, y_] := x^n + y^n;\n        End[]\n        EndPackage[]\n\nIn[2]:= SumSquares[1,2];\nOut[2]= 5\n\nIn[3]:= n=3;\n        SumSquares[1,2];\nOut[2]= 5\n位于Private环境内的函数和变量无法被在Package外部访问, 因此我们手动在Package内 引用SumSquares函数, 使其能够被外部调用.\n\n\n\n\n本文中大部分的例子来源于相应函数的文档, 还有一部分来自于Wolfram的讲座, 你可以 从这里获取到演示笔记本, 本节的内容对应于Module 7.\n关于创建Paclet包, 单元测试, 创建文档等相关内容会放在下篇中讨论."
  },
  {
    "objectID": "posts/Double_Well_Potential/index.html",
    "href": "posts/Double_Well_Potential/index.html",
    "title": "双阱势问题",
    "section": "",
    "text": "顾名思义, 双阱势是由两个势阱组成的体系. 这样的体系有很多可能 的势函数, 例如:\n\n方势阱: \\[ V_{\\text{sq}} = \\Biggr\\{\n\\begin{aligned}\n& 0 \\quad \\text{ if } |x-(\\frac{a}{2} \\pm b)| < \\frac{c}{2}\\\\\n& V_0 \\quad \\text{otherwise}\n\\end{aligned}\n\\]\n由两个抛物线势阱构成的双阱势: \\[ V_{\\text{para}}(x) = \\frac{V_{\\text{cusp}}}{b^{2}} \\Biggl(\\Biggl|x-\\frac{a}{2}\\Biggr| - b \\Biggr)^{2} \\]\n或者, 常见于对称性破缺中的墨西哥帽势: \\[ V_{\\text{m}}(x) = \\frac{V_{\\text{max}}}{b^{4}} \\Biggl(\\Biggl(x-\\frac{a}{2}\\Biggr)^{2} - b^{2}\\Biggr)\\]\n\n其中, \\(a\\) 是体系整体的长度, \\(b\\) 是体系中心到势阱中心的距离, \\(c\\) 是势阱的宽度. 图 Figure 1 展示了这几种势的样子.\n\n\nCode\nusing Plots, LaTeXStrings\ntheme(:ggplot2, yticks=nothing, grid=nothing, linewidth=2)\na,b,c = 1.0, 0.25, 0.3\nv0,vcusp,vmax = 1.0, 1.5, 0.4\nvsq(x) = (abs(x-0.5a+b)<0.5c||abs(x-0.5a-b)<0.5c) ? 0 : v0\nvpara(x) = vcusp/(b^2)*(abs(x-0.5a)-b)^2\nvm(x) = vmax/(b^4)*((x-a/2)^2-b^2)^2\nxticks = (\n  [0.0,0.5a-b,0.5a,0.5a+b],\n  [L\"0\", L\"\\frac{1}{2}-\\frac{b}{a}\", L\"\\frac{1}{2}\", L\"\\frac{1}{2}+\\frac{b}{a}\"]\n)\n\nplt = plot(\n  [vsq, vpara, vm], 0:0.01:1,\n  xlabel = L\"x/a\", ylabel = L\"V(x)\",\n  label = [L\"V_{\\rm{sq}}\" L\"V_{\\rm{para}}\" L\"V_{\\rm{m}}\"],\n  annotation = [\n    (0.5, vpara(0.5)+0.1, (L\"V_{\\rm{cusp}}\", 10)),\n    (0.5, vm(0.5)+0.1, (L\"V_{\\rm{max}}\", 10)),\n    (0.15, v0+0.1, (L\"V_0\", 10)),\n    (0.5a-b, 0.7v0-0.1, (L\"c\", 10))\n  ], xticks=xticks\n)\nplot!(x->v0, 0:0.5:1, label=nothing, ls=:dot)\nplot!(x->0.7v0, 0.5a-b-0.5c:0.1c:0.5a-b+0.5c, label=nothing, c=:black, arrow=(:closed, :both), lw=1)\nplt\n\n\n\n\n\nFigure 1: 双阱势的一些可能的例子\n\n\n\n\n接下来我们来求解双阱势问题. 不难看出, 当势垒高度趋向无穷时, 无限深方势阱的解也是双阱势问题的解. 因此很直观的, 我们取无限 深方式阱的解\\(\\ket{n}\\)作为基:\n\\[ \\psi_{n}(x) = \\braket{x|n} = \\Biggl\\{\n\\begin{aligned}\n  & \\sqrt{\\frac{2}{a}}\\sin \\Biggl(\\frac{n \\pi x}{a}\\Biggr) \\quad & \\text{if } 0<x<a\\\\\n  & 0 & \\text{otherwise}\n\\end{aligned}\\]\n假设双阱势解为:\n\\[ \\ket{a} = c_{m} \\ket{m} \\]\n那么由定态Schrodinger方程, 我们得到:\n\\[ H_{nm}c_{m} = E c_{n} \\]\n其中, 矩阵元\\(H_{nm}\\) 为:\n\\[ H_{nm} = \\bra{n}H\\ket{m} = \\frac{2}{a}\\int _{0}^{a} \\sin \\Biggl(\\frac{n \\pi x}{a}\\Biggr)V(x)\\sin\\Biggl(\\frac{n \\pi x}{a}\\Biggr) {\\rm d}x \\]"
  },
  {
    "objectID": "posts/BlogMigrate2022/BlogMigrate2022.html",
    "href": "posts/BlogMigrate2022/BlogMigrate2022.html",
    "title": "新-网站迁移记录",
    "section": "",
    "text": "在上一次网站迁移后, 网站遇到了一系列问题:\n首先是非80/443端口的流量导致IP被GFW封了两次, 我的VPS服务商还不提供更换IP的服务, 只能换一个机子然后迁移数据, 很麻烦; 解决这个也不难, 只将80端口用于VPN服务, 其他的功能都只暴露在本地端口, 通过VPN访问, 但是这并不适用于博客, 毕竟博客的初衷就是大家都能看到(虽然也没人看就是了).\n第二个就是自己写的博客框架过于简陋了点, 导致写起来很不爽, 最近又发现了Quarto这个好东西, 于是决定迁移到Quarto上来, 刚好Quarto也支持博客功能."
  },
  {
    "objectID": "posts/BlogMigrate2022/BlogMigrate2022.html#服务商选择",
    "href": "posts/BlogMigrate2022/BlogMigrate2022.html#服务商选择",
    "title": "新-网站迁移记录",
    "section": "服务商选择",
    "text": "服务商选择\n部署博客网站的服务商有很多选择, 综合价格(或者说白嫖额度)和国内访问速度来看, Cloudflare是比较好的选择, 因此选择部署在Cloudflare Page上.\n图床也顺便从自己的服务器上迁移了出来, 也用的是Cloudflare的服务, 虽然Cloudflare的Image服务要收费, 但是R2储存功能有10G的免费额度, 同时免费流量(准确的说Cloudflare不按流量收费, 而是所谓的操作次数,也就是访问次数)也不像七牛云那样只支持HTTP."
  },
  {
    "objectID": "posts/BlogMigrate2022/BlogMigrate2022.html#技术细节",
    "href": "posts/BlogMigrate2022/BlogMigrate2022.html#技术细节",
    "title": "新-网站迁移记录",
    "section": "技术细节",
    "text": "技术细节\n\n博客部署\n这套方案最大的问题就是Cloudflare Page不像Github Page那样有Github Action的支持, 同时也不原生支持Quarto框架, 这导致部署环境并编译到静态网页很麻烦. 因此选择使用Github Action, 先部署到Github Page, 然后Cloudflare Page的储存库指向Github Page分支即可, 构建设置全部留空即可 \nGithub Action方面, 参考Quarto官方提供的示例仓库, 同时由于我主要使用的是Julia, 需要手动配置一下环境, 这样才能正确渲染出代码输出(你也可以选择不在云端重新计算, 直接使用本地计算结果), 流程如下:\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        with:\n          tinytex: true \n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      - run: pip install jupyter\n      - uses: julia-actions/setup-julia@v1\n        with:\n          version: 1.8\n      - run: julia -e 'using Pkg;deps=readlines(\"requirements.txt\");for dep in deps Pkg.add(dep) end'\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n值得注意的点是, 由于Julia目前对虚拟环境的支持没有Python那么好, 因此我选择手动将所有需要的库写入requirements.txt中, 然后依次安装.\n\n\nHTTPS\nCloudflare为网站开启HTTPS后, Cloudflare会自动为你注册并续签一个Let’s Encrypt的免费证书.\n\nP.S. 如果你需要开启HTTPS的不是Cloudflare Page这类的第三方托管的服务, 而是来自你的服务器的内容, Cloudflare为你提供了自签名的为期10年的SSL证书, 你只需要在服务器上部署这个证书, 就能实现服务器到Cloudflare之间的加密, 而用户端到Cloudflare间的加密仍由Cloudflare注册并自动续签的证书负责.\n\n\n\nQuarto设置\n关于用Quarto来创作, 官方提供了很详细的文档, 同时,Albert Rapp也撰写了一篇很好的文章, 详细的介绍了利用Quarto进行博客创作的各种细节与流程."
  },
  {
    "objectID": "posts/Noether定理/Noether定理.html",
    "href": "posts/Noether定理/Noether定理.html",
    "title": "Noether定理",
    "section": "",
    "text": "最近看Atland的凝聚态场论, 对Noether定理的证明与讲解的部分感到有些含糊(毕竟这种东西应该放在理力里讲), 在此做一些总结\n\n\n\n考虑一个泛函\\(\\mathcal{J}\\):\n\\[\\mathcal{S}(q) = \\int _{t_0}^{t_1} \\mathcal{L}(t, q, \\dot{q},\\cdots, q^{(n)}){\\rm d}t\\tag{1}\\]\n若存在一个函数\\(\\phi(t, q, \\dot{q},\\cdots,q^{k})\\)满足,\n\\[\\frac{\\rm d}{{\\rm d} t}\\phi(t, q, \\dot{q},\\cdots,q^{(k)}) = 0\\tag{2}\\]\n则称上式为\\(\\mathcal{S}\\)的\\(k\\) 阶守恒律, 相应的\\(\\phi\\) 称为\\(\\mathcal{S}\\) 的守恒量.\n\nExample 1\n考虑一个不显含时间的作用量: \\[\\mathcal{S}(q) = \\int _{t_0}^{t_1}\\mathcal{L}(q,\\dot{q}){\\rm d} t\\] 显然的,我们可以找到其一阶守恒律 \\[H = \\dot{q} \\frac{\\partial \\mathcal{L}}{\\partial \\dot{q}} - \\mathcal{L}\\]\n\n\n\n\n对于一个给定的作用量：\n\\[ \\mathcal{S}(q) = \\int ^{t_1}_{t_0} \\mathcal{L}(t,q,\\dot{q}){\\rm d} t \\tag{3}\\]\n考虑两个单参变换,并要求他们是\\(C^{\\infty}\\)的:\n\\[ X=\\theta(t,q;\\epsilon)\\quad Y = \\psi(t,q;\\epsilon) \\tag{4}\\]\n满足:\n\\[ \\theta(t,q;0)=t\\quad \\psi(t,q;0) = q \\tag{5}\\]\n\nExample 2\n平移变换:\\(X=x+\\cos \\theta \\;\\epsilon, Y=y+\\sin \\theta\\; \\epsilon\\)\n旋转变换:\\(X = x\\cos \\epsilon + y \\sin \\epsilon,Y = -x\\sin \\epsilon + y\\cos \\epsilon\\)\n\nJacobian矩阵为:\n\\[ J=\\frac{\\partial (X,Y)}{\\partial(t,q)} = \\begin{pmatrix}\\frac{\\partial \\theta}{\\partial t} & \\frac{\\partial \\theta}{\\partial q}\\\\ \\frac{\\partial \\psi}{\\partial t} & \\frac{\\partial \\psi}{\\partial q}\\end{pmatrix}  = \\begin{pmatrix}\\theta_{t}& \\theta_{q}\\\\ \\psi_{t} & \\psi_{q}\\end{pmatrix} \\tag{6}\\]\n行列式为:\n\\[ |J| = \\theta_{t} \\psi_{q} - \\theta_{t}\\psi_{q} \\tag{7}\\]\n当\\(\\epsilon=0\\) 时,我们有:\n\\[ |J| = 1 \\tag{8}\\]\n由于\\(\\theta\\) 与\\(\\psi\\) 均是\\(C^{\\infty}\\)的, \\(|J|\\) 也是连续的,因此在\\(\\epsilon=0\\) 的一个足够小的邻域内\\(|J|\\neq 0\\),即, 我们可以找到一组逆映射将\\((X,Y)\\) 映回\\((t,q)\\):\n\\[ t = \\Theta(X,Y;\\epsilon)\\quad q = \\Psi(X,Y;\\epsilon) \\tag{9}\\]\n现在考虑一个给定的轨迹\\(q(t)\\),变换后的轨迹由一组参数方程给定:\n\\[ X_{\\epsilon} = \\theta(t,q;\\epsilon)\\quad Y_{\\epsilon} = \\psi(t,q;\\epsilon) \\tag{10}\\]\n现在我们可以定义变分不变性,作用量\\(\\mathcal{S}\\) 的拉氏量\\(\\mathcal{L}\\) 称为在区间\\([t_0,t_1]\\) 上变分不变,当其满足,对\\(\\forall [a,b]\\in[t_0,t_1]\\), \\(\\exist\\delta\\in \\mathbb{R}\\),使得\\(\\forall \\epsilon< \\delta\\):\n\\[ \\int^{a}_{b}\\mathcal{L}(t,q,\\dot{q}) {\\rm d} t = \\int^{a_{\\epsilon}}_{b_{\\epsilon}}\\mathcal{L}(X_{\\epsilon},Y_{\\epsilon} ,\\dot{Y_{\\epsilon}}){\\rm d} X \\tag{11}\\]\n\nExample 3\n\\[ \\mathcal{L}(t,q,\\dot q) = \\dot q^{2}(x) + q^{2}(x) \\] 考虑时间平移变换: \\[ X = t+\\epsilon,\\quad Y=q \\] 我们有 \\[ \\dot Y_{\\epsilon} = \\dot q \\] 则,对于给定的一个区间\\([t_0,t_1]\\), 我们有: \\[ \\int^{t_1}_{t_0}(\\dot q^{2} + q^{2}) {\\rm d}t = \\int ^{t_1+\\epsilon}_{t_0+\\epsilon}(\\dot Y_{\\epsilon} + Y^{2}_{\\epsilon})=\\int^{t_1+\\epsilon}_{t_0+\\epsilon}(\\dot q + q(t-\\epsilon)){\\rm d}t \\] 成立,即上式的拉氏量在时间平移变换下是不变的\n\n进一步的,在讨论Noether定理前,我们介绍一种描述变换的通用方式,即1 :\n\\[ \\begin{aligned}X\\approx t + \\epsilon \\zeta \\\\ Y\\approx q+\\epsilon \\eta\\end{aligned} \\tag{12} \\]\n其中, \\(\\epsilon,\\eta\\) 为任意光滑函数, 称为变换的生成函数. 具体的, 与(4)式比较,我们有:\n\\[ \\begin{aligned}\\zeta(t,q) = \\left.\\frac{\\partial \\theta}{\\partial \\epsilon}\\right|_{(t,q;0)} \\\\ \\epsilon(t,q) = \\left.\\frac{\\partial \\psi}{\\partial \\epsilon}\\right|_{(t,q;0)} \\end{aligned} \\tag{13}\\]\n\n\n\nNoether定理:若\\(\\mathcal{L}(t,q,\\dot q)\\)在\\([t_0,t_1]\\)上对于生成函数为\\(\\zeta,\\eta\\) 的变换具有变分不变性, 则:\n\\[ \\eta\\frac{\\partial \\mathcal{L}}{\\partial \\dot q} + \\zeta\\left(\\mathcal{L} - \\frac{\\partial \\mathcal{L}}{\\partial \\dot q}\\dot q\\right) = \\text{const} \\tag{14}\\]\n在作用量\\(\\mathcal{S}\\) 的任意极值轨道上成立.\n\\[ \\mathcal{S}  =\\int ^{t_1}_{t_0}\\mathcal{L}(t,q,\\dot q){\\rm d} t \\tag{15}\\]\n(13)式也可以写为:\n\\[ \\eta p - \\zeta \\mathcal{H} = \\text{const} \\tag{16}\\]\n\\(p = \\frac{\\partial \\mathcal{L}}{\\partial \\dot q}\\) 为相对于\\(q\\) 的广义动量, \\(\\mathcal{H} = \\mathcal{L} - p\\dot q\\)为哈密顿量.\n\nProof. 令 \\[  \\widetilde{\\mathcal{S}}(q) = \\int^{b}_{a}\\mathcal{L}(t,q,\\dot q){\\rm d} t \\] 由定义(11), \\(\\forall [a,b]\\in [t_0, t_1]\\), 有: \\[ \\widetilde{S}(Y_{\\epsilon})  - \\widetilde{S}(q) = \\int^{b_{\\epsilon}}_{a_{\\epsilon}}\\mathcal{L}(X,Y_{\\epsilon},\\dot Y_{\\epsilon}) {\\rm d} X - \\int^{b}_{a}\\mathcal{L}(t,q,\\dot q){\\rm d} t = 0\\] 对于足够小的\\(\\epsilon\\)成立, 我们有: \\[ X = t+\\epsilon \\zeta + O(\\epsilon^{2}) = t + \\epsilon X_{0} \\] \\[ Y_{\\epsilon} = q+  \\epsilon \\eta + O(\\epsilon^{2}) = q + \\epsilon Y_{0} \\] 或者, 上式给定了\\(\\delta t = \\zeta, \\delta q = \\eta\\).\n对于上述变分问题, 其取极值时, 我们有: \\[ \\left.p \\delta q - \\mathcal{H} \\delta t\\right|^{x_1}_{x_2} = 0\\] 代入: \\[ \\eta p - \\zeta \\mathcal{H}|^{b}_{a} = 0 \\] 由于\\(a,b\\)为满足 \\(t_0\\leq a < b\\leq t_1\\)的任意实数, 因此上式成立的唯一可能为: \\[  \\eta p - \\zeta \\mathcal{H} = \\text{const} \\] Q.E.D\n\n进一步的, 对于\\(n\\) 个自由度的体系,Noether定理可以进行推广,拉氏量的形式变为\\(\\mathcal{L}(t,{\\bf q},\\dot {\\bf q})\\), \\({\\bf q} = (q_1,\\cdots, q_{n})\\), 给定由\\(\\zeta,\\eta_{k}\\)生成的变换,其中:\n\\[ Y_{k} = q_{k} + \\epsilon \\eta_{k} \\tag{17}\\]\n广义动量与哈氏量为2 : \\[ \\begin{aligned}&p_{k} = \\frac{\\partial \\mathcal{L}}{\\partial \\dot q_{k}} \\\\\n&\\mathcal{H} = p_{k}\\dot q_{k} - \\mathcal{L}\\end{aligned}\\tag{18}\\] 则守恒量为:\n\\[ p_{k} \\eta_{k} - \\mathcal{H} \\zeta = \\text{const} \\]\n接下来,我们展示几个具体的例子:\n\n时间平移不变性和能量守恒\n考虑时间变换\\(T=t+\\epsilon, Q_{k} = q_{k}\\) 我们有:\n\\[\\begin{aligned}\\zeta = 1, \\eta_{k} = 0\\end{aligned}\\]\n则相应的守恒量为:\n\\[ \\mathcal{H} = \\text{const} \\]\n即, 能量守恒对应于时间平移不变性.\n空间平移不变性与动量守恒\n考虑空间平移变换:\n\\[ T = t, Q_{k} = q_{k} + \\epsilon \\eta_{k} \\]\n则守恒量为:\n\\[ p_{k} \\eta_{k} = \\text{const} \\]\n即, 动量守恒对应于空间平移不变性.\n空间旋转不变性与角动量守恒\n由于三维旋转较为复杂, 我们作为例子仅考虑绕\\(z\\) 轴的一个旋转.\n\\[T = t\\] \\[Q_{1} = q_{1}\\cos \\epsilon + q_{2} \\sin \\epsilon\\] \\[Q_{2} = -q_{1}\\sin \\epsilon + q_{2} \\cos \\epsilon\\] \\[Q_{3} = q_{3}\\]\n取\\(\\epsilon\\to 0\\) 的极限(即,无穷小旋转),我们有:\n\\[ \\zeta=0, \\eta_{1} = q_2, \\eta_{2} = -q_1, \\eta_3 = 0\\]\n对应的守恒量为:\n\\[ p_1 q_2 - p_2 q_1 = \\text{const} \\]\n这就是角动量的\\(z\\) 分量,即空间旋转对称性对应于角动量守恒."
  },
  {
    "objectID": "posts/2021上杂谈/2021上杂谈.html",
    "href": "posts/2021上杂谈/2021上杂谈.html",
    "title": "2021年上半年ACG杂谈",
    "section": "",
    "text": "谁能想到上半年最好看的两部番分别是萌豚和偶像番呢?(死宅真恶心.jpg) ### 当季作品\n\n赛马娘II 9.5/10\n我心目中近三年来最好看的番, 人物形象很鲜明, 节奏把握的也很好,. 帝王和麦昆的友谊(百合)也拍的很好. 双涡轮和帝王有马纪念复活两集属实展示了一个偶像番能有多热血. 动画质量上整体也比第一季好了不少(虽然还是有祖传谜之3D).\n如果一定要说缺点的话, 一个就是题材相对比较小众. 另一个就是刻画米浴的两集和主线有些脱节, 和双涡轮不同, 米浴的故事对主角影响不大, 不过考虑到帝王的职业生涯很大一部分都在伤病中度过, 需要一些其他故事来填充内容, 也算上无伤大雅(而且做的好看啊).\n整体来说算是神作, 可惜国内没有赛马文化, 导致在国内不温不火. 不过BD销量充分证明了实力和受欢迎程度. 期待第三季(cy多给小特一些剧情吧, 第二季斯佩酱完全成节目效果了).\n摇曳露营 第二季 9.2/10\n芳文社拿手的废萌百合番, 老套的题材, 但功力一看便知. 人物不需要一些夸张而不真实的萌属性来展示萌点, 也没有什么高深而复杂的内核与立意. 对日常的细节刻画可以说是第一梯队的水平.\n没啥好说的, 质量相当上乘的废萌日常番.\n奇巧计程车 9.2/10 很不错的原创番, 脚本制作水平很高(虽然也有点同行衬托的因素在里面). 如果一定要找缺点的话可能一个在于情节较为紧凑, 如果分成两季比较好. 另一点在于很多内容塞到了广播剧里, 导致如果你不去认真看广播剧, 动画里很多剧情存在bug, 这一点可能也是时长限制的原因.\n佐贺偶像是传奇 第二季 8.5/10\n没看过第一季, 挺新奇的设定(僵尸偶像就离谱). 不过细究下来可以理解作者使用这一设定的目的. 很多偶像番之所以烂, 是没有讲好偶像的成长, 换句话说, 主角是怎么成长为偶像的. 而佐贺在这点做的就很好. 让一群”死气沉沉”的僵尸, 来拯救佐贺死气沉沉的经济, 带动观众, 带动生者. 我觉得至少在展现偶像的成长上佐贺做的不错.\n奇蛋物语 8.4/10 作画和演出非常优秀, 但是剧情上略显拉跨, 单元剧的撕裂感太强, 最后经典的奇幻转科幻机械降神. 整部番剧的动画制作和脚本制作不在一个水平线上, 后期烂尾略显严重.\nB站评论沾点饭圈, 另外特别篇也是有够烂的.(这两点不参与评分).\nRE0: 从零开始的异世界生活 第二季后半 8.2/10\n先高喊:“白狐,我的超人!”. 白狐的制作真的非常良心了, 最后结尾也是制作的比较好的, 燃起来了.jpg. 画面上场景的光影拿捏挺不错的,其他方面也保持在中上水平.\n缺点也比较明显:\n\n台词太冗长了. 虽然长月老贼就是这种风格, 但是动画里镜头一拉给个远景, 然后大伙动也不动, 要么就绕着一个东西转, 然后就开始一直念了, 特别是到剧情中段的时候.\n谜语人剧情. 虽然小说里也是这个剧情, 但动画里做的属实有点太谜语人了, 导致我一个知道剧情的人都看晕了,就挺离谱的.\n\n关于我转生成为史莱姆这件事 第二季 8/10\n看完以后甚至不知道日记和这个哪个才是番外了, 真的水. 上半部分有成魔王的情节撑着, 感觉下半年的文戏部分会更水.\nvivy: 萤石眼之歌 8/10\n歌很好听, 如果有上半年最佳配乐奖应该就颁给他了.很熟悉的机器人对心的探讨, 不同的是这次换了个非战狂的文艺演员来. 第四集空间站坠落算是神回了, 但最后结局处理不是很好. 而且很多设定上存在一些问题, 大概把机器人理解成某种精灵就没问题了.\n(不过唱歌机器人到底是用扬声器还是声带啊)\n86 不存在的战区 7/10\n可以看出来作者觉得自己想出来了一个很cool的想法, 但我觉得, 你如果想讲一个现实主义的故事, 那你的设定在现实一定是可行的. 86不受信任, 被派到前线去死, 骗服役五年变成正常人的谎言也破灭了, 动画里也没展现出zf对86的高压统治或是情报管理, 86不造反只能说离了天下之大谱.\n其他各种nt设定也一堆, 但除开设定的问题都还不错.\n致不灭的你 6.5/10\n前两集挺吸引人的, 但后面实在是太拖沓了, 画面在21年的水平下不算好.\n很优秀的设定, 但脚本和制作的水平没能将这个设定发挥出来. 再加上后续漫画和动画的一些分歧(指某站弹幕), 导致观感不佳.\n\n\n\n\n剃须,然后捡到女高中生\n奇怪的设定, 有一些靠设定引流的嫌疑. 喜欢设定的可以去看.\n打了三百年史莱姆, 不知不觉就升到了满级\n没啥新意的泡面番, 图一乐可以看看\n水果篮子 最终季\n终于完结了, 算是很久远的回忆了.\n\n\n\n\n\n蔚蓝反射 澪\n画风令人震惊, 很像少年宫里画的彩铅画(高情商:淡雅). 百合扭曲的剧情, 拍的真的迷, 强烈不推荐观看.\n伊甸星原\n如果你是妖尾厨那么建议去再刷一遍妖尾, 不要来这里上当. 而且还沾点媚俗.\n\n\n\n\n\n异种族风俗娘评鉴指南 8.5/10 怎么说呢, 介于里表之间的番剧, 制作水平其实相当不错. 题材相当新颖. 缺点的话一个就是评测不咋样, 怎么没把内核写好呢. 第二个就是其实也不是很异种族, 绝大多数异种族风俗娘都得到了极大的拟人化, 沾点XP噱头了.\n\n\n\n\n\n没怎么看, 就日常看海贼,然后看了巨人. 海贼没啥好说的, 能早日完结我就心满意足了, 巨人也没啥好说的, jscnmsl.\n\n\n\nmeme\n\n\n\n\n\n全nm在玩群星和lol了, 基本没怎么推新游戏.\n\nNier Replicant 重制版 8.4/10\n重置的还是不错的, 白金发挥稳定, 算是帮我这种从机械纪元才入坑的玩家补了补剧情.\n手感一流.\n剧情还不错, 有新意, 反正我玩到一半的时候是一点都猜不到后面的剧情.\n地图,怪物和流程设计算是扣分项, 首先绝大多数怪物的攻击方式都没有区别(我感觉还没4399丰富), 其次地图也有点阴间, 尤其是机械山, 各种任务之类的重复度也相当高.\n人物上对主角和妹妹的刻画其实比较失败, 但对两个同伴, 凯尼和埃米尔绝对是很大的亮点(埃米尔, 我的埃米尔😭😭😭)\n生化危机:村庄 8/10\n重启之后第二部, 万众期待的机8, 首先声明, Capcom做的相当好, 完全值得一个九分的成绩, 但是傻逼的国区定价-1分"
  },
  {
    "objectID": "posts/LatexThesisTips/LatexThesisTips.html",
    "href": "posts/LatexThesisTips/LatexThesisTips.html",
    "title": "毕业论文写作有感",
    "section": "",
    "text": "最近用在写毕业论文, 之前没有使用LaTeX编写过这类较长的中文文档, 遇到了一些问题, 因此做个总结和记录, 也包含一些之前遇到的问题, 一并记录在此(好像该改名叫LaTeX Tips的说).\n\n\n\n所有的设置和自定义命令都应该较好的排序和分类(所谓的Preamble, 导言区), 并在可能的情况下组织进一个单独的.cls或.sty 文件中.\n\n对于毕业论文这一类较长的文件来说, 请利用\\input和\\include命令, 将内容拆分到多个文件内, 并合理的组织这些文件的路径. 例如, 在根目录下建立一个pages文件夹存放子文件, pages文件夹内按照章节建立chapter文件夹, 然后每个section对应一个 独立文件.\nP.S. 关于\\input和\\include的差别, 可以参见StackOverflow上的回答.\n\n中文排版请使用ctex, 请不要再使用CJK系列宏包!\n请注意备份与版本管理, 我推荐使用git.\n推荐你使用latexmk进行编译. 使用latexmk时, 一个很好的习惯是设置输出路径, 例如:\n#~/.latexmkrc\n$out_dir = '.latexmk_build';\n这样你可以获得一个干净的工作目录. 也更方便设置.gitignore.\n一点算是私活的内容, 相比于MikTeX, 我更推荐Texlive, 因为它更主流, 包也更全(Texlive 2022刚出, 感兴趣的可以试一试).\n不算是Tips, 只是提一嘴, 其实LaTeX编译很大一部分时间浪费在磁盘IO上, 因此装在SSD上一般可以提升编译速度; 另一点, 据说Texlive和MikTex在Windows上的实现都包裹了一层兼容层, 因此Windows上LaTeX编译的速度要比Linux上慢很多.\n\n\n\n\n\n请正确的使用各种符号, 包括但不限于:\n\n微分符号请不要直接打一个d上去, 正确的微分符号是正体, 并且带有半宽的空格, 请使用physics宏包, 其中提供了一系列规范且方便的命令, 可见下图: \n说到正体, 也请注意其他的符号(sin, cos, ln等), 往往也是正体, 对于它们, 大部分都有提供指令直接输出正确的格式(\\sin, \\cos, \\ln). 对于没提供, 以 及需要在公式中输入正体字符的时候, 请使用\\mathrm, 不要用\\text.\n请正确的区分和选择各类花体字符:\n\n\\mathbb, \\(\\mathbb{RQCZV}\\).\n\\mathcal, \\(\\mathcal{RQCZV}\\).\n\\mathfrak, \\(\\mathfrak{RQCZV}\\).\n\\mathsf, \\(\\mathsf{RQCZV}\\).\n\n单位输入请使用siunitx宏包.\n\n使用\\[\\]来创建Display Math环境, 而不是$$$$.\n请尽量使用equation环境, 再嵌套一个aligned环境可以应付99%的公式.\nequation的一个优势是公式自动编号, 对于不需要编号的公式请使用equation*环境, 章节编号可以通过\\numberwithin命令设定.\n还是公式编号, 引用公式请先在equation环境中插入\\label{eq:xxx}, 引用时使用\\ref{eq:xxx}, 这样可以实现编号变更后自动同步, 并且会在PDF文件中 生成可以点击跳转的链接.\n公式中, 使用括号等符号时(特别是公式中还有分式时)请尽量使用\\left \\right组合, 下面展示了直接输入括号和使用\\left\\right的差别:\n(\\frac{\\lambda \\psi(x, \\lambda)}{\\psi_1}(x, \\lambda)) = \\left(\\frac{\\lambda \\psi(x, \\lambda)}{\\psi_1(x, \\lambda)}\\right)\n\\[\n(\\frac{\\lambda \\psi(x, \\lambda)}{\\psi_1}(x, \\lambda)) = \\left(\\frac{\\lambda \\psi(x, \\lambda)}{\\psi_1(x, \\lambda)}\\right)\n\\]\n\n\n\n\n\nLaTeX中, {}可以起到和C语言中类似的作用. 例如, \\centering, \\bf等的作用域只会影响{}内的内容.\n接上条, 也请注意不要滥用{}, {\\centering }输入更方便, 但是合理换行并缩进的:\n\\begin{center}\n  ...\n\\end{center}\n具有更高的可读性.\nLaTeX是一个历史悠久并且使用广泛的语言, 这意味着你几乎99.99%的需求都可以通过前人开发的便捷且规范的宏包来解决. 因此在造轮子之前, 请搜索一下有没有相应的宏包, 或者其他人的解决方案.\nStackExchange可以解决你99.99%的问题."
  },
  {
    "objectID": "posts/Car_Parrinello_Molecule_Dynamics/Car_Parrinello_Molecule_Dynamics.html",
    "href": "posts/Car_Parrinello_Molecule_Dynamics/Car_Parrinello_Molecule_Dynamics.html",
    "title": "Car-Parrinello 分子动力学",
    "section": "",
    "text": "这篇文章主要基于Car-Parrinello 1985年的PRL文章[1]与Understanding Molecular Simulations一书[2].\n\n\n简单来说, CPMD(Car-Parrinello molecular dynamics)是一种ab initio MD方法. 在DFT理论得到提出并应用后, 通过DFT计算出体系的势后, 再执行MD的算法. 这就是BOMD(Born-Oppenheimer MD)的思想. BOMD通过BO近似将原子核与电子解耦, 但相应的缺点就是我们需要进行计算耗时较长的SCF. 为提升AIMD的计算效率, Car和Parrinello在1985年发表了一篇文章, 提供了CPMD这一方法. CPMD不将原子核与电子的运动解耦, 而是为电子引入一个虚质量, 并直接进行简单经典MD算法.\n\n\n\n\n\n对于一个给定的体系, 其Hamiltonian由KS泛函给出:\n\\[ H_{KS}({\\bf r}) = -\\frac{1}{2} \\nabla^2 + V_{ext}({\\bf r}) + V_{KS}[n]({\\bf r})\\]\n其中\\(V_{KS}[n]({\\bf r})\\) 是电子密度的泛函. 常规的SCF做法是给定一个初始电子密度\\(n({\\bf r})\\), 然后重复计算 \\(V_{KS}[n]({\\bf r})\\)和\\(n({\\bf r})\\) 直到自洽. 但是我们可以通过Rayleigh-Ritz方法来直接 对泛函进行最小化, 求得电子基态.\n一旦我们给定了体系电子波函数的一组基 \\(\\{b_{k}({\\bf r})\\}\\) , 体系的波函数可以写为:\n\\[ \\psi_{i}({\\bf r}) = \\sum^{N_{b}}_{k=1}c_{ik}b_{k}({\\bf r}),\\;i=1,\\cdots,N_{e}\\]\n则\\(H_{KS}\\) 现在就是系数\\(\\{c_{ik}\\}\\) 的一个多元函数. 求解电子基态的任务变为求使$E({c_{ik}} $ 最小的\\(\\{c_{ik}\\}\\).\n同时为了保证正交性, 我们需要带有约束:\n\\[ \\int \\psi_{i}^{*}({\\bf r}) \\psi_{j}({\\bf r}) = \\delta_{ij}\\]\n即:\n\\[ \\sum_{k,k'=1}^{N_{b}}c^{*}_{ik} c_{jk'} \\left(\\int b_{k}^{*}({\\bf r}) b_{k'}({\\bf r})\\right) - \\delta_{ij} = 0 \\]\n但很明显, 我们面对的是一个\\(N_{b}\\times N_{e}\\)维的函数优化问题, 计算量非常巨大.\n幸运的是, 在两年前, Kirkpatrick, Delatt和Vecchi提出了著名的模拟退火算法[3], 使得我们有希望快速的 求解这类优化问题. 同时, Car和Parrinello意识到, 模拟退火算法的动力学是Metropolis算法, 这一算法 在相空间中搜索最小值非常高校, 但问题在于我们得到的轨迹没有物理意义. Car和Parrinello构建了如下的 Lagrangian, 通过牛顿力学对参数进行优化:\n\\[ \\mathcal{L} =  \\underbrace{\\sum_{i}\\frac{1}{2}\\mu \\int |\\dot{\\psi}_{i}({\\bf r})|^2 {\\rm d}{\\bf r}}_{\\text{Damping}} - E[\\{\\psi_{i}\\}] + \\underbrace{\\sum_{ij}\\Lambda_{ij}\\left[\\int \\psi_{i}^{*}({\\bf r})\\psi_{j}({\\bf r})-\\delta_{ij}\\right]}_{\\text{Lagranian multipliers}}\\]\n可以看出, Car和Parrinello增加了两项:\n\n第一项阻尼项, 其中\\(\\mu\\)为电子的虚拟质量.\n第三项拉格朗日乘子项, 用于满足约束条件.\n\n\n\n\n我们将原子核的部分显式的写出:\n\\[  \\begin{aligned}\\mathcal{L} = &\\sum \\frac{1}{2}\\mu \\int|\\dot{\\psi}({\\bf r})|^{2} + \\sum_{I}\\frac{1}{2}M_{I}\\dot{{\\bf R}_{I}}^{2}+\\sum_{v}\\frac{1}{2}\\mu_{v}\\dot{\\alpha}^{2}_{v}\\\\\n&-E[\\{\\psi_{i}\\},\\{{\\bf R}_{I}\\}, \\{\\alpha_{v}\\}]+\\sum_{ij}\\Lambda_{ij}\\left[\\int \\psi_{i}^{*}({\\bf r})\\psi_{j}({\\bf r}) - \\delta_{ij}\\right]\\end{aligned} \\]\n其中, \\({\\bf R}_{I}\\)为原子核的坐标, \\(M_{I}\\)为原子核质量, \\(\\alpha_{v}\\) 为影响体系能量的外参量, 例如压强, 体积等. 我们也相应的为\\(\\alpha_{v}\\)添加了阻尼项, 带有虚质量\\(\\mu_{v}\\).\n从上式中, 我们可以得到几个参数在相空间中的运动方程:\n\\[ \\left\\{\\begin{aligned}\n&\\mu \\ddot{\\psi}_{i} = -\\frac{\\delta E}{\\delta \\psi_{i}^{*}} + \\sum_{k}\\Lambda_{ik}\\psi_{k}\\\\\n&M_{I}\\ddot{{\\bf R}}_{I} = - \\nabla_{{\\bf R}_{I}}E\\\\\n&\\mu_{v}\\ddot{\\alpha}_{v} = -\\frac{\\partial E}{\\partial \\alpha_{v}}\n\\end{aligned}\\right.\\]\n上式即为CPMD的核心运动方程. 对于\\(\\psi_{i}\\), 我们更进一步将其展开为\\({\\bf c}_{i} = (c_{i1}, \\cdots, c_{iN_{b}})\\)的方程:\n\\[ \\mu \\ddot{{\\bf c}}_{i} = -\\left(H {\\bf c}_{i} - \\sum_{k}\\lambda_{ik}{\\bf c}_{k}\\right)\\]\n之后, 就可以通过经典的MD算法计算.\n\n\n\n\n\n\nCPMD的优势是一目了然的: 我们不需要每一步都完整求解一次DFT. 我们只需要在最开始的时候进行一次DFT计算, 求得\\(\\{c_{ik}\\}\\)的初始值即可.\n而缺点相应的也有:\n\n模型中多了一个超参数\\(\\mu\\).\n稳定收敛的时间步长比BOMD要小(解释见后).\n精确度低于BOMD.\n\n\n\n\nCPMD的关键就是虚质量的引入, 一个很自然的问题就是, 虚质量该如何选取? 它会如何影响计算的结果? 答案是, 理论上虚质量越小计算越精确. 在CPMD中, 随着体系原子核的运动, 我们不重新计算电子波函数, 而是 基于运动方程进行更新, 这一做法的正确性是由绝热定理保证的. 而当虚质量较大时, 体系中会存在较大的从原子核 到电子的动能转移, 从而破坏绝热条件, 导致计算出现误差.\n另一方面, 较小的电子虚质量, 要求MD算法采用更小的时间步, 来保证计算收敛.\n一般来说, 电子虚质量的取值为\\(400 \\sim 800 \\;{\\rm a.u.}\\).\n另外, 已被证明, 当\\(\\mu\\to 0\\)的极限下, CPMD收敛于BOMD.\n\n\n\n在CPMD中, 拉格朗日乘子也随着时间演化, 通过SHAKE算法进行更新, 如果你感兴趣, 可以查阅参考资料.[4]\n\n\n\n\n\n[1] Phys. Rev. Lett., 55 (1985)\n\n[2] Daan Frenkel, Berend Smit, Understanding Molecular Simulations, Academic Press (2002)\n[3] Science, 22, 671-680.\n[4] arXiv:cond-mat/0610552."
  },
  {
    "objectID": "posts/Wigner定理/Wigner定理.html",
    "href": "posts/Wigner定理/Wigner定理.html",
    "title": "Wigner定理",
    "section": "",
    "text": "在我们开始谈论时间反演之前, 我们讨论更多关于量子力学对称性的问题.\n我们首先回顾量子力学的基本原理, 我们认为, 任何量子态对应于Hilbert空间中的一个 矢量, 同时他们在乘以一个复系数的情况下仍代表相同的态, 即\\(c \\ket{a}\\) 和 \\(\\ket{a}\\) 是一个态, 这样, 一个态实际上对应于Hilbert空间中态矢量张成的一个一维 空间, 或者说一条射线. 这使得我们有动机引入等价关系:\n\\[\\ket{s_1} \\sim \\ket{s_2} \\Leftrightarrow \\exists c \\in \\mathbb{C}, \\ket{s_1} = c \\ket{s_2}\\]\n进一步的, 我们可以得到商空间, 也就是射影空间\\(\\mathbb{P} \\mathcal{H}\\):\n\n\n不难看出, 射影空间 \\(\\mathbb{P} \\mathcal{H}\\) 不是矢量空间, 而是因为 我们把 \\(0\\) 元素移出了.\n\\[\\mathbb{P} \\mathcal{H} = \\mathcal{H} - \\{0\\} / \\sim\\]\n我们将矢量 \\(\\ket{s}\\) 属于的射线记作\\(\\ket{\\overline{s}}\\), 射线间的内积定义为 两射线内任意归一化矢量的内积.\n那么我们首先定义对称变换为:\n\nDefinition 1 (对称变换) 给定Hilbert空间\\(\\mathcal{H}\\) 及相应的射影空间\\(\\mathbb{P} \\mathcal{H}\\), 若有映射 \\(f: \\mathbb{P}\\mathcal{H} \\to \\mathbb{P} \\mathcal{H}\\) 满足:\n\\[ |\\braket{\\overline{s_1}|\\overline{s_2}}|^{2} = |\\braket{f(\\overline{s_1})|f(\\overline{s_2})}|^{2},\\quad \\forall s_1,s_2\\in \\mathbb{P} \\mathcal{H} \\]\n则称\\(f\\) 是一个对称变换\n\n此处我们定义的对称变换是射影空间\\(\\mathbb{P} \\mathcal{H}\\) 上的映射, 我们希望能与 Hilbert空间上的映射建立联系, 由\\(\\mathcal{H}-\\{0\\}\\) 到 \\(\\mathbb{P} \\mathcal{H}\\) 的自然同态, 我们不难定义:\n\nDefinition 2 (相容) 给定Hilbert空间\\(\\mathcal{H}_1, \\mathcal{H}_{2}\\)与相应的射影空间 \\(\\mathbb{P} \\mathcal{H}_{1}, \\mathbb{P}\\mathcal{H}_{2}\\), 设分别有映射 \\(G: \\mathcal{H}_{1} \\to \\mathcal{H}_{2}\\), \\(f: \\mathbb{P} \\mathcal{H}_{1} \\to \\mathbb{P} \\mathcal{H}_{2}\\), 若满足:\n\\[ G(\\ket{s}) \\in f(\\ket{\\overline{s}}),\\quad \\forall \\ket{s}\\in \\mathcal{H}_{1}\\]\n则称\\(G\\) 和\\(f\\) 是相容的."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blogs",
    "section": "",
    "text": "新-网站迁移记录\n\n\n\n\n\n最近服务器被连着封了两次IP, 不堪其扰, 决定将部分功能迁移到Cloudflare等公共服务商上.\n\n\n\n\n\n\nDec 1, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWigner定理\n\n\n\n\n\n这里, 我们讲讨论一些关于Hilbert空间的问题, 并进一步介绍Wigner定理.\n\n\n\n\n\n\nNov 19, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n双阱势问题\n\n\n\n\n\n量子力学中的双阱势问题\n\n\n\n\n\n\nNov 14, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n网站迁移记录\n\n\n\n\n\n记录一下迁移网站的过程, 以作备忘之需.\n\n\n\n\n\n\nMar 9, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n毕业论文写作有感\n\n\n\n\n\n记录一下用LaTeX撰写毕业论文时的一些想法和经验.\n\n\n\n\n\n\nMar 4, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\nMathematica包开发(一)\n\n\n\n\n\n\n\nComputer Science\n\n\n\n\nMathematica长期以来都给人一种大号计算器的感觉, 这里介绍一个更接近于传统意义上的编程语言中的应用: 将代码组织并封装成一个包\n\n\n\n\n\n\nJan 4, 2022\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\nCar-Parrinello 分子动力学\n\n\n\n\n\n\n\nPhysics\n\n\n\n\n直接将DFT计算应用在分子动力学的每一步上在计算成本上过于高昂, 因此, 引入了一种简化的分子动力学方法: Car-Parrinello分子动力学.\n\n\n\n\n\n\nOct 29, 2021\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n黑体辐射\n\n\n\n\n\n\n\nPhysics\n\n\n\n\n对于黑体辐射问题, 存在两种推导方式, 他们采用了不同的假设, 这里分别进行讨论, 并对比他们之间的等价性在哪.\n\n\n\n\n\n\nSep 21, 2021\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n自动微分(Automatic Differentiation)\n\n\n\n\n\n求任意函数的微分是数值方法中很重要的一个内容, 不同于计算物理中常用的简单数值微分, 这里我们介绍在ML等领域中常用的另一种微分方式: 自动微分\n\n\n\n\n\n\nAug 26, 2021\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n2021年上半年ACG杂谈\n\n\n\n\n\n\n\n\n\n\n\n\nJul 26, 2021\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\nNoether定理\n\n\n\n\n\n\n\nPhysics\n\n\n\n\n一个简化的, 初等的对Noether定理的证明和讨论\n\n\n\n\n\n\nMar 4, 2021\n\n\nYuanqing Wu\n\n\n\n\n\n\n  \n\n\n\n\n直积,直和与张量积\n\n\n\n\n\n\n\nMaths\n\n\nPhysics\n\n\n\n\n物理学中常常混淆直积, 直和以及张量积, 这里做一点讨论和区分\n\n\n\n\n\n\nOct 14, 2020\n\n\nYuanqing Wu\n\n\n\n\n\n\nNo matching items"
  }
]